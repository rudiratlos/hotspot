#!/bin/bash
set +e

snam="${0##*/}"

hotspotver="V0.967"
opt1="$1"
opt2="$2"
opt3="$3"
opt4="$4"

torstart="no"
wgstart="no"
nodogsplashstart="no"
ovpnstart="no"
ovpnrefreshbeforestart="no"

aptaddinstlist="tor openvpn wireguard"

eth_dev="eth0"
# freq_filter: 2|5 GHz band
freq_filter="2"
if [ "$freq_filter" != "5" ]; then freq_filter="2"; fi
# if defined, automatic discovery disabled
ch_autofind="1"
ch_dflt="11"
# valid channels and selection prio
ch_2GHz_ovrlap="2 3 4 5 7 8 9 10 12 13"
ch_2GHz_022MHz="1 6 11"
ch_5GHz_020MHz="32 36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 132 136 140 144 149 153 157 161 165 169 173"
ch_5GHz_040MHz="34 38 46 54 62 102 110 118 126 134 142 151 159"
ch_5GHz_080MHz="42 58 106 122 138 155"
ch_5GHz_160MHz="50 114"
ch_prio=${ch_2GHz_ovrlap}" "${ch_2GHz_022MHz}" "${ch_5GHz_020MHz}" "${ch_5GHz_040MHz}" "${ch_5GHz_080MHz}" "${ch_5GHz_160MHz}
# wl0_dev: on board wlan (e.g. wlan0)
# wl1_dev: external wlan adaptor (optional)
wl0_dev=""
wl1_dev=""
ap_dev="ap0"
ap_devmac="b8:27:eb:00:00:00"
ap_net="10.3.141"
ap_devext="$eth_dev"
ns_dom="local"

ap_restricted="no"
ap_share="no"
ap_ip="${ap_net}.1"
ap_subn="${ap_net}.255"
ap_ipanet="${ap_net}.1/24"
ap_iptsubn="${ap_net}.0/24"
ap_revip=`echo "$ap_ip" | awk -F "." '{ print $4"."$3"."$2"."$1 }'`
ap_revnet=`echo "$ap_ip" | awk -F "." '{ print $3"."$2"."$1 }'`
ap_cauri="http://${ap_ip}/index.html"

# The UID that Tor runs as (varies from system to system)
tor_uid=$(id -u debian-tor 2>/dev/null) #Debian/Ubuntu
if [ "$tor_uid" == "" ]; then tor_uid=$(id -u tor 2>/dev/null); fi #ArchLinux/Gentoo
if [ "$tor_uid" == "" ]; then tor_uid="109"; fi #As per assumption
tor_trans_port="9050"
tor_dns_port="53053"
tor_subn="10.192.0.0/10"

if [ "$wl0_dev" == "" ]; then
# internal wlan adapter
  wl0_devs=`ls -l --full-time /sys/class/net/ 2>/dev/null | grep -iE "mmc.*wlan" | cut -d" " -f9`
  wl0_dev=`echo "$wl0_devs" | awk -F " " '{ print $1 }'`
  if [ "$wl0_dev" == "" ]; then wl0_dev="wlan0"; fi
fi
if [ "$wl1_dev" == "" ]; then
# external wlan adapter via usb
  wl1_devs=`ls -l --full-time /sys/class/net/ 2>/dev/null | grep -iE "usb.*wlan" | cut -d" " -f9`
  wl1_dev=`echo "$wl1_devs" | awk -F " " '{ print $1 }'`
fi

wpactrl="/var/run/wpa_supplicant"
wpasupg="/etc/wpa_supplicant/wpa_supplicant.conf"
hostapdf="/etc/hostapd/hostapd.conf"
dnsmasqf="/etc/dnsmasq.conf"
dnsmasqcpf="no"
crdaf="/etc/default/crda"
tordir="/etc/tor"
torcfg="$tordir/torrc"
hostn="`hostname`"
usr="`whoami`"
fbdev="/dev/fb0"
qrshow="yes"
qrfile="/tmp/qrcode.png"
# spot_ssid="${hostn}-hotspot"  # <hostname>-hotspot
spot_ssid=`echo "$hostn" | sed 's/./\U&/g'`wlan-`cat /sys/class/net/$wl0_dev/address | awk -F ":" '{print $4$5$6}'`  # <HOSTNAME>wlan-<lastMAC3byte>
spot_psk="hallohallo"
spot_cntry2="`locale | awk -F"[_.]" '/LANG=/{print $2}'`"
if [ "$spot_cntry2" == "" ]; then spot_cntry2="DE"; fi
hostapd_ssid=`cat $hostapdf | grep ^ssid= | awk -F "=" '{ print $2 }'`
hostapd_psk=`cat $hostapdf | grep ^wpa_passphrase= | awk -F "=" '{ print $2 }'`
if [ "$hostapd_ssid" == "" ]; then hostapd_ssid="$spot_ssid"; hostapd_psk="$spot_psk"; fi

# free wg server for testing https://www.jagoanssh.com

# wireguard defines
wg_dev="wg0"
# wg networks: pivpn: 10.6.0
wg_net="10.6.0"
wg_ipclient="${wg_net}.2"
wg_ipsrv="${wg_net}.1"
wg_ipsnet="${wg_ipsrv}/24"
wg_dns="9.9.9.9, 149.112.112.112"
wg_top="/etc/wireguard"
wg_cfg="$wg_dev"
wg_fil="$wg_top/$wg_cfg.conf"
#e.g. format "URSgXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXJEPQY="
wg_srvpubkey=""
wg_clientprivkey=""
wg_presharedkey=""
wg_listenport="51820"
# e.g.      "wg.example.com:51820"
wg_endpoint="wg.example.com:$wg_listenport"
wg_publkeyf="vpn-public.key"
wg_privkeyf="vpn-private.key"

# openvpn defines
# e.g.  "AT CH DE ES FR GB JP KR SC TW US"
ovpnsel="AT CH DE ES FR GB JP KR SC TW US"
ovpntop="/etc/openvpn"
ovpnlogdir="/var/log/openvpn"
ovpnlogfil="$ovpnlogdir/openvpn.log"
ovpncfg="$snam"
ovpnfil="$ovpntop/$ovpncfg.conf"
_ovpndev=`cat $ovpnfil 2>/dev/null | grep -E "^.{0}dev " | awk -F " " '{print $2}'`
if [ "$_ovpndev" == "" ] || [ "$_ovpndev" == "tun" ]; then _ovpndev="tun0"; fi
if [ ! -d "$ovpnlogdir" ] && [ "$ovpnlogdir" != "" ]; then mkdir -p $ovpnlogdir; fi 

ovpn_dev="$_ovpndev"

# vpngate defines
vpngdir="$ovpntop/client"
vpngate="${vpngdir}/vpngate.csv"
vpngatefileage="900"
vpngpwd="vpngate.pwd"
vpngpwdpath="${vpngdir}/${vpngpwd}"
if [ "$ovpnlogfil" != "" ]; then vpnglogpar="--log $ovpnlogfil"; else vpnglogpar=""; fi
ovpnopt="--auth-nocache $vpnglogpar --config $ovpnfil"
if [ "$vpngpwd" != "" ]; then ovpnopt="$ovpnopt --auth-user-pass $vpngpwdpath"; fi

# firewalld defines
fwdnoif="lo $ap_dev $ovpn_dev"
pubzone="--zone=public"
apperm=""
apzone="--zone=home"
ovpnzone="$pubzone"
wgzone="$pubzone"
trustzone="--zone=trusted"

#autostrt not needed anymore since V0.960, use hotspot enable/disable instead
autostart="yes"

# etc defines
startdate=`date +"%Y%m%d%H%M%S"`
hsautocreate="$startdate file autocreated by $snam, do not edit" 
RED="\033[0;31m"
GREEN="\033[0;32m"
NC="\033[0m" # No Color

function _msgdat { echo -e `date +"%Y-%m-%d %T"` "$1"; }
function _msg    { echo -e "$1"; }
function _msgerr { _msg "${RED}ERR:${NC} $1"; }
function _msgsuc { _msg "${GREEN}SUC:${NC} $1"; }
function _msgred { _msg "${RED}$1${NC}"; }
function _msggrn { _msg "${GREEN}$1${NC}"; }
function mark    { export $1=`pwd`; }

function showip {
  _ret=1
  _chkurl="https://myip.expert/"
# _ext_ip0=$(wget -q -T10 -U "curl" -O - http://whatismyip.akamai.com/)
  _ext_ip=`dig txt o-o.myaddr.test.l.google.com @ns1.google.com +short -4 2>/dev/null | sed 's/"//g'`
  if [ "$_ext_ip" != "" ]; then
    _msg "    CheckIP external ${1}-ip: $_ext_ip"
    _msg "    CheckIP $_chkurl"
#   curl -s $_chkurl
    wget -q -T10 -U "curl" -O - $_chkurl
    _ret=$?
  else
    _msg "    CheckIP ERROR"
  fi
  return $_ret
}

function qrcode_on_oled  {
# show access info on a small OLED screen
# qrcode_on_oled "x" "http://xx.xx.xx.xx"
# qrcode_on_oled "x" "WIFI:S:$hostapd_ssid;T:WPA2;P:$hostapd_psk;;"
  if [ "$qrshow" == "yes" ] || [ "$1" == "interactive" ]; then
    if [ "$2" != "" ] && [ "$qrfile" != "" ]; then 
      /usr/bin/qrencode -o "$qrfile" "$2"
      if [ -f "$qrfile" ] && [ -e "$fbdev" ]; then
#       echo "  QRcode  show $2"
        /usr/bin/fbi -noverbose -T 1 -a -d "$fbdev" "$qrfile" 2>/dev/null
#       rm "$qrfile"
      fi
    fi
  fi
}

function Show_Defines {
  _msg "eth_dev:$eth_dev eth_subn:$eth_subn ap_ipanet:$ap_ipanet"
  _msg "wl0_dev:$wl0_dev wl0_subn:$wl0_subn wl0_ip:$wl0_ip"
  _msg "wl1_dev:$wl1_dev wl1_subn:$wl1_subn wl1_ip:$wl1_ip"
  _msg "ap_shar:$ap_share hs_try:$hs_try $wl1_dev avail: $wl1_avail"
  _msg "wl0_dev:$wl0_dev wl0_devs: $wl0_devs"
  _msg "wl1_dev:$wl1_dev wl1_devs: $wl1_devs"
  _msg "apdvext:$ap_devext"
}

function Hotspot_Defines {
  ovpn_ip=`ip addr show dev "$ovpn_dev" 2>/dev/null | awk '/inet / { print $2 }'`
  eth_ip=`ip addr show dev "$eth_dev" 2>/dev/null   | awk '/inet / { print $2 }'`
  wl0_ip=`ip addr show dev "$wl0_dev" 2>/dev/null   | awk '/inet / { print $2 }'`
  eth_subn=`ip addr show dev "$eth_dev" 2>/dev/null | awk '/inet / { print $4 }'`
  wl0_subn=`ip addr show dev "$wl0_dev" 2>/dev/null | awk '/inet / { print $4 }'`
  if [ "$wl1_dev" != "" ]; then
    wl1_avail="yes"
    wl1_ip=`ip addr show dev "$wl1_dev" 2>/dev/null   | awk '/inet / { print $2 }'`
    wl1_subn=`ip addr show dev "$wl1_dev" 2>/dev/null | awk '/inet / { print $4 }'`
    if [ "$eth_ip" == "" ]; then ap_devext="$wl1_dev"; fi
  else
    if [ "$eth_ip" == "" ]; then ap_devext="$wl0_dev"; fi
  fi
  hs_try="no"
  if [ "$eth_subn" != "$ap_subn" ]; then
    if [ "$wl1_avail" == "yes" ] || [ "$eth_subn" == "$wl0_subn" ] || [ "$wl0_subn" == "" ]; then hs_try="yes"; fi
  fi

  acc_info=""
  if [ "$hs_try" == "yes" ]; then
#   acc_info="WIFI:S:$spot_ssid;T:WPA2;P:$spot_psk;;"
    acc_info="WIFI:S:$hostapd_ssid;T:WPA2;P:$hostapd_psk;;"
  else
    if [ "$wl1_ip" != "" ];   then acc_info="$wl1_ip"; fi
    if [ "$eth_ip" != "" ];   then acc_info="$eth_ip"; fi
    if [ "$wl0_ip" != "" ];   then acc_info="$wl0_ip"; fi
    acc_info=`echo "$acc_info" | awk -F "/" '{ print $1 }'`
    if [ "$acc_info" != "" ]; then acc_info="http://$acc_info"; fi
#   echo "$acc_info"
  fi

  bckext=`date +"%Y%m%d%H%M%S"`
# Show_Defines
}

function fil_bck {
  if [ "$1" != "" ] && [ -f "$1" ]; then
    if [ "$2" != "" ]; then fn="$1.$2"; else fn="$1.old"; fi
    cp "$1" "$fn"
  fi
}

function IP4_fwdSet {
  if [ "$1" == "1" ]; then _opt="1"; else _opt="0"; fi
# _fil="/proc/sys/net/ipv4/ip_forward"
# echo "$_opt" > "$_fil"
  sysctl -w net.ipv4.ip_forward=$_opt >/dev/null
}

function IP4_fwdShow { sysctl net.ipv4.ip_forward; }

function Hotspot_Status {
  _msg "Status $snam ..."
  systemctl -n50 status $snam
  _msg ""
  ps ax | grep wpa_
  _msg ""
  ip a
  _msg ""
  hostname -I
}

function Check_installed_PKG {
  _ret=1
# Check that what we need is installed
  for command in iw firewalld hostapd dnsmasq; do
    if [ "$command" != "" ]; then
      which $command 2>&1 >/dev/null
      if [ $? -ne 0 ]; then
        _msgerr "  $command is not installed (use $snam setup)"
      else
        _ret=0
      fi
    fi
  done
  return $_ret
}

function Mod_Para {
  fnv="file_not_valid"
  cfil="$fnv"
  case "$1" in
    self)    cfil="$0" ;;
    hostapd) cfil="$hostapdf" ;;
    dnsmasq) cfil="$dnsmasqf" ;;
    crda)    cfil="$crdaf" ;;
    ovpncfg) if [ -d "$vpngdir" ]; then cfil="$ovpnfil"; fi ;;
    ovpnpwd) if [ -d "$vpngdir" ]; then cfil="$vpngpwdpath"; fi ;;
    torcfg)  if [ -d "$tordir" ];  then cfil="$torcfg"; fi ;;
  esac

  if [ "$cfil" != "$fnv" ]; then
    _msg "    change  $1 $2 $3 ($cfil)"
    case "$1" in
      ovpnpwd) echo -e "$2\n$3" > $cfil ;;
      ovpncfg|torcfg) sed -i -r "s/^$2[ ]* .*/$2 $3/g" "$cfil" ;;
      self) sed -i -r "s&^$2[ ]*=.*&$2=\"$3\"&g" "$cfil" ;;
      *) sed -i -r "s/^$2[ ]*=.*/$2=$3/g" "$cfil" ;;
    esac
  else
    _msg "    Mod_Para invalid file selector $1"
    Check_installed_PKG
  fi
}

function Hotspot_Enable  {
  _msg "Enable $snam service ..."
  systemctl enable  $snam.service
}

function Hotspot_Disable  {
  _msg "Disable $snam service ..."
  systemctl disable  $snam.service
}

# + ##### ipt functions not used anymore #####
function ipt_cln {
  echo "  ipt     $1 $2"
  iptables -t nat -F
  iptables -t mangle -F
  iptables -t nat -X
  iptables -t mangle -X
  iptables -t raw -F
  iptables -t raw -X
  iptables -F
  iptables -X
}

function ipt_chains {
  echo "  ipt     chains"
  iptables -P INPUT   ACCEPT
  iptables -P OUTPUT  ACCEPT
  iptables -P FORWARD ACCEPT
}

function ipt_ap {
  echo "  ipt     ap   $1 $ap_devext $ap_dev $ap_iptsubn"
  iptables -t nat $1 POSTROUTING -s $ap_iptsubn ! -d $ap_iptsubn -j MASQUERADE
  iptables $1 FORWARD -i $ap_devext -o $ap_dev -m state --state RELATED,ESTABLISHED -j ACCEPT
  iptables $1 FORWARD -i $ap_dev -o $ap_devext -j ACCEPT
}

function ipt_ovpn {
  echo "  ipt     ovpn $1 $ovpn_dev $ap_dev"
  iptables -t nat $1 POSTROUTING -o $ovpn_dev -j MASQUERADE
  iptables $1 FORWARD -i $ovpn_dev -o $ap_dev -m state --state RELATED,ESTABLISHED -j ACCEPT
  iptables $1 FORWARD -i $ap_dev -o $ovpn_dev -j ACCEPT
}

function ipt_tor {
  echo "  ipt     tor  $1 $ap_dev (using ports 53 $tor_dns_port $tor_trans_port)"
  iptables -F
  iptables -t nat -F  
  iptables -t nat $1 PREROUTING -i $ap_dev -p udp --dport 53 -j REDIRECT --to-ports $tor_dns_port
  iptables -t nat $1 PREROUTING -i $ap_dev -p udp --dport $tor_dns_port -j REDIRECT --to-ports $tor_dns_port
  iptables -t nat $1 PREROUTING -i $ap_dev -p tcp --syn -j REDIRECT --to-ports $tor_trans_port
}

function ipt_do {
  if [ "$1" == "add" ] || [ "$1" == "del" ] || [ "$1" == "remove" ]; then
    echo "  ipt     $1 $2"
    if [ "$1" == "add" ];  then opt="-A"; else opt="-D"; fi
    if [ "$2" == "tor" ];  then ipt_tor  "$opt"; fi
    if [ "$2" == "ovpn" ]; then ipt_ovpn "$opt"; fi
    if [ "$2" == "ap" ];   then ipt_ap   "$opt"; fi
  else
    echo "  ipt     invalid option $1"
  fi
}
# - ##### ipt functions not used anymore #####

function fwd_list {
  case "$1" in
    all)      firewall-cmd --list-all ;;
    allzones) firewall-cmd --list-all-zones ;;
    active)   firewall-cmd --list-all-zones | awk '!/^[[:blank:]]/ && /active/ {p=1} !/^[[:blank:]]/ && !/active/ {p=0} p' ;;
    *) echo "Usage: $snam fwd list [all|active]" ;; 
  esac  
}

function fwd_log {
  case "$1" in
    all) firewall-cmd --set-log-denied=all ;;
    off) firewall-cmd --set-log-denied=off ;;
    *) echo "Usage: $snam fwd log [all|off]" ;; 
  esac  
}

function fwd_stat { 
  _msgred "+ $1 ######################################################"
  ip a
  netstat -tulpn
  fwd_list active
  iptables -t nat -nvL PREROUTING
  _msgred "- $1 ######################################################" 
}

function fwd_wipe {
  _ret=1
  step="fwd_wipe"
  rm -rf /etc/firewalld/zones > /dev/null 2>&1
# Purge old iptables rules
  iptables -t nat -F > /dev/null 2>&1
  iptables -t mangle -F > /dev/null 2>&1
  iptables -t nat -X > /dev/null 2>&1
  iptables -t mangle -X > /dev/null 2>&1
  iptables -t raw -F > /dev/null 2>&1
  iptables -t raw -X > /dev/null 2>&1
  for i in $(iptables -S | awk '{print $2}' | uniq ); do 
    iptables -F $i > /dev/null 2>&1
    iptables -Z $i > /dev/null 2>&1 
    iptables -X $i > /dev/null 2>&1
  done
# iptables -F > /dev/null 2>&1
# iptables -Z > /dev/null 2>&1
# iptables -X > /dev/null 2>&1
# iptables-save  > /etc/iptables/rules.v4
# ip6tables-save > /etc/iptables/rules.v6
  systemctl restart firewalld
  _ret=$?
  return $_ret
}

function fwd_def {
# 1:add|remove 2:service|port|interface|... [3:value] [4:"--permanent"] [5:"--zone=<zone>"] [6:step]
# /usr/lib/firewalld/services
  _ret=1
  _mode=""
  _errf="/tmp/ERR_fwd_def.txt"
  _step="$6"
  _zone="$5"
  _perm="$4"
  _valu="$3"
  if [ "$_valu" != "" ]; then _valu="=$_valu"; fi
  if [ "$_step" == "" ]; then _step="fwd_def"; fi
# if [ "$_zone" != "$apzone" ] && [ "$_zone" != "$pubzone" ]; then _zone="$apzone"; fi
  if [ "$_zone" == "" ]; then _zone="$apzone"; fi
  if [ "$1" != "" ] && [ "$2" != "" ]; then
    _msg "    $_step $1 $2 $3 $_zone $_perm"
#   _msg "firewall-cmd $_perm $_zone --$1-$2$_valu"
    firewall-cmd $_perm $_zone --$1-$2$_valu >$_errf 2>&1
    _ret=$?
    if [ $_ret -ne 0 ] && [ "$_mode" == "test" ]; then 
      _msgerr "$_ret $step: firewall-cmd $_perm $_zone --$1-$2$_valu"
      cat $_errf
      rm  $_errf
    fi
  else
    _msgerr "  fwd_def missing param #1[add|remove] #2[service|port|...]"
  fi
  return $_ret
}

function fwd_if {
# 1:add|remove [2:opt-permanent] [3:step]
  step="fwd_if "
  if [ "$3" != "" ]; then step="$3"; fi
# _msg "    $step $1 $2"
  ret=1
  for i in $( ifconfig -a | sed 's/[ \t].*//;/^\(\)$/d' | awk -F ":" '{ print $1 }' ); do
    if [[ "$fwdnoif" != *"$i"* ]]; then
      fwd_def "$1" interface "$i" "$2" "$pubzone" "$step"
      ret=$?
    fi
  done
  return $ret
}

function fwd_vpns {
# 1:add|remove [2:"--permanent"] [3:step]
# remove regular interfaces, if tunnel will be build
  if [ "$1" == "add" ]; then _act="remove"; else _act="add"; fi
  fwd_if  "$_act" "$2" "$3"
  _ret=$?
  return $_ret
}

function fwd_ovpn_part2 {
# attach tun interface to ovpn zone
  step="fw2ovpn"
# fwd_def "$1" service   openvpn     "$2" "$apzone"   "$step"
  fwd_def "$1" interface "$ovpn_dev" "$2" "$ovpnzone" "$step"
  _ret=$? 
  return $_ret
}

function fwd_ovpn {
# remove/add all interfaces from ovpn zone in contrast to tun interface
# 1:add|remove [2:"--permanent"]
  fwd_vpns "$1" "$2" "fwdovpn"
  _ret=$?
  return $_ret
}

function fwd_wg_part2 {
# attach wg interface to wg zone
  step="fw2_wg "
  fwd_def "$1" interface "$wg_dev" "$2" "$wgzone" "$step"
  _ret=$? 
# experimental
#  iptables -A -t -nat POSTROUTING -o wlan0 -j MASQUERADE 
#  iptables -A -t -nat POSTROUTING -o wlan1 -j MASQUERADE
#  iptables -A -t -nat POSTROUTING -o eth0 -j MASQUERADE
#  firewall-cmd $2 --direct --$1-rule ipv4 nat POSTROUTING 0 -o wlan0 -j MASQUERADE 
#  firewall-cmd $2 --direct --$1-rule ipv4 nat POSTROUTING 0 -o wlan1 -j MASQUERADE 
#  firewall-cmd $2 --direct --$1-rule ipv4 nat POSTROUTING 0 -o eth0  -j MASQUERADE  
  return $_ret
}

function fwd_wg {
# remove/add all interfaces from wireguard zone in contrast to wg interface
# 1:add|remove [2:"--permanent"]
  fwd_vpns "$1" "$2" "fwd_wg "
  _ret=$?
  return $_ret
}

function fwd_tor {
# Anonymizing Middlebox: https://gitlab.torproject.org/legacy/trac/-/wikis/doc/TransparentProxy
# 1:add|remove [2:"--permanent"]
  step="fwd_tor"
  mode="" 
  _errf="/tmp/ERR_fwd_tor.txt"
  rm  $_errf >/dev/null 2>&1
# fwd_def "$1" service "tor-socks" "$2" "$apzone" "$step"
  iptables -F
  iptables -t nat -F
  firewall-cmd $2 --direct --$1-rule ipv4 nat PREROUTING 0 -i $ap_dev -p udp --dport 53 -j REDIRECT --to-ports $tor_dns_port >>$_errf 2>&1
  firewall-cmd $2 --direct --$1-rule ipv4 nat PREROUTING 0 -i $ap_dev -p udp --dport $tor_dns_port -j REDIRECT --to-ports $tor_dns_port >>$_errf 2>&1
  firewall-cmd $2 --direct --$1-rule ipv4 nat PREROUTING 0 -i $ap_dev -p tcp --syn -j REDIRECT --to-ports $tor_trans_port >>$_errf 2>&1
  _ret=$?
  if [ $_ret -ne 0 ] && [ "$_mode" == "test" ]; then 
    _msgerr "$_ret $step"
    cat $_errf
    rm  $_errf >/dev/null 2>&1
  fi
  return $_ret
}

function fwd_ap {
# 1:add|remove [2:"--permanent"]
  step="fwd_ap"
  fwd_def   "$1"     masquerade ""            "$2" "$pubzone"   "$step "
  if [ "$ap_restricted" == "yes" ]; then
    fwd_def "$1"     interface  "$ap_dev"     "$2" "$apzone"    "$step "
    _ret=$?
    fwd_def "$1"     service    http          "$2" "$apzone"    "$step "
    fwd_def "$1"     service    https         "$2" "$apzone"    "$step "
    fwd_def "$1"     service    dns           "$2" "$apzone"    "$step "
    fwd_def "$1"     service    dhcp          "$2" "$apzone"    "$step "
#   fwd_def "$1"     service    upnp-client   "$2" "$apzone"    "$step "
#   fwd_def "$1"     service    ntp           "$2" "$apzone"    "$step "
#   fwd_def "remove" service    samba-client  "$2" "$apzone"    "$step " # default service not required
  else
    fwd_def "$1"     interface  "$ap_dev"     "$2" "$trustzone" "$step "
    _ret=$?
    fwd_def "$1"     source     "$ap_iptsubn" "$2" "$trustzone" "$step "
  fi
  return $_ret
}

function fwd_do {
# 1:add|del|remove 2:servicename
  step="fwd_do"
  _ret=1
  if [ "$1" == "add" ] || [ "$1" == "remove" ]; then
    if [ "$1" == "add" ];    then _opt="add"; else _opt="remove"; fi
    _msg "    $step $opt $2"
    if [ "$2" == "ap" ];     then fwd_ap   "$_opt" "$apperm"; _ret=$?; fi
    if [ "$2" == "tor" ];    then fwd_tor  "$_opt" "$apperm"; _ret=$?; fi
    if [ "$2" == "ovpn" ];   then fwd_ovpn "$_opt" "$apperm"; _ret=$?; fi
    if [ "$2" == "wg" ];     then fwd_wg   "$_opt" "$apperm"; _ret=$?; fi
  else
    _msgerr "  $step  invalid option $1 $2 $3 $4"
  fi
  return $_ret
}

function ovpn_cfg_dwn {
# download and create ovpn config files, source: www.vpngate.net
#HostName,IP,Score,Ping,Speed,CountryLong,CountryShort,NumVpnSessions,Uptime,TotalUsers,TotalTraffic,LogType,Operator,Message,OpenVPN_ConfigData_Base64
  _ret=1
  vpnurl="https://www.vpngate.net/api/iphone/"
  _msg "    dwnload $vpnurl"
  wget -q -O $vpngate $vpnurl
  _ret=$?
  if [ -f "$vpngate" ]; then
    vg_filn2="${vpngdir}/vpngate_scores.txt"
    vg_filn3="${vpngdir}/vpngate_bestscore.ovpn"
    echo -e "vpn\nvpn" > ${vpngdir}/vpngate.pwd
    rm $vg_filn2 >/dev/null 2>&1
    nr=0
    vpnsel_arr=($ovpnsel)
    while read line; do
      vg_hname=`echo "$line" | awk -F "," '{print $1}'`
      vg_ipadr=`echo "$line" | awk -F "," '{print $2}'`
      vg_score=`echo "$line" | awk -F "," '{print $3}'`
      vg_cntlg=`echo "$line" | awk -F "," '{print $6}'`
      vg_cntsh=`echo "$line" | awk -F "," '{print $7}'`
      vg_confg=`echo "$line" | awk -F "," '{print $15}'`
      vg_filn1="${vpngdir}/vpngate_${vg_cntsh}_${vg_hname}.ovpn"
      idx=0
      while [ "${vpnsel_arr[idx]}" != "" ]; do
        if [ "$vg_cntsh" == "${vpnsel_arr[idx]}" ]; then
          nr=$(($nr+1))
          _msg "    create  $vg_filn1"
          echo "$vg_score $vg_cntsh $vg_hname $vg_ipadr" >>$vg_filn2
          echo $vg_confg | base64 --decode 2>/dev/null | tr -d "\r" >$vg_filn1
          if [ "$nr" -eq "1" ]; then 
            cp $vg_filn1 $vg_filn3
            cp $vg_filn1 $ovpntop/${snam}.conf
          fi
        fi
        idx=$(($idx+1))
      done
    done <<< $(cat $vpngate)
    chmod 600 ${vpngdir}/vpngate*
  fi
  return $_ret
}

function ovpn_refresh {
  _ret=1
  if [ -d "$vpngdir" ]; then
    dodwn="yes"
    if [ -f "$vpngate" ]; then
#     test file is recent (not older than xx mins)
      if [ `stat --format=%Y $vpngate` -ge $((`date +%s` - $vpngatefileage)) ]; then
        dodwn="no"
      fi
    fi
    if [ "$dodwn" == "yes" ]; then
      ovpn_cfg_dwn
      _ret=$?
    else
      _msg "    file is recent ($vpngate)"
    fi
#   rm $vpngate >/dev/null 2>&1
  fi
  return $_ret
}

function ovpn_check_running {
  _ret=0
  vpnpid=`ps -ef | grep openvpn | grep -v grep | awk '{print $2}'`
  if [ ! -z $vpnpid ]; then
#  OpenVPN is currently running
   echo $vpnpid | xargs kill
  fi
  return $_ret
}

function wg_check_running {
  _ret=0
  vpnpid=`ps -ef | grep wg | grep -v grep | awk '{print $2}'`
  if [ ! -z $vpnpid ]; then
#  wg is currently running
   echo $vpnpid | xargs kill
  fi
  return $_ret
}

function wg_up {
  _ret=1
  step="wg_up"
  if [ "$1" == "" ]; then _cfg="$wg_dev"; else _cfg="$1"; fi
  if [ -f "$wg_top/$_cfg.conf" ]; then
    _msg "    $step   start cfg $_cfg $wg_ipclient (experimental)"
    IP4_fwdSet "1"
    systemctl start wg-quick@$_cfg
    _ret=$?
    if [ $_ret -eq 0 ]; then
#     wait max. 60sec for wg device gets an IPadr
      i="0"
      wg_ip=""
      while [ $i -le 60 ] && [ "$wg_ip" == "" ]; do
        sleep 1
        wg_ip=`ip addr show dev "$wg_dev" 2>/dev/null | awk '/inet / { print $2 }'`
        _msg "    $step   wait for $wg_dev to come up"
        i=$[$i+1]
      done
      if [ "$wg_ip" != "" ]; then
        _msg "    OK wg   $wg_dev $wg_ip"
        fwd_do "add" "wg"
        _ret=$?
        fwd_wg_part2 "add" "$apperm"
        _ret=$?
        if [ $_ret -eq 0 ]; then showip "wg"; fi
#       fwd_stat "wg"
      else
        _msgerr "  $step   no IPassignment on $wg_dev"
      fi
    else
      _msgerr "  $step   ret:$_ret can not start with systemctl start wg-quick@$_cfg "
    fi
  else 
    _msgerr "$step missing $wg_top/$_cfg.conf, use hotspot wg config"
  fi
  return $_ret
}

function wg_dwn {
  _ret=1
  step="wg_dwn"
  if [ "$1" == "" ]; then _cfg="$wg_dev"; else _cfg="$1"; fi
  if [ -f "$wg_top/$_cfg.conf" ]; then
    _msg "    $step  stop cfg $_cfg"
    systemctl stop wg-quick@$_cfg
    _ret=$?
    fwd_do       "remove" "wg"
    _ret=$? 
    fwd_wg_part2 "remove" "$apperm"
  else 
    _msgerr "$step missing $wg_top/$_cfg.conf, use hotspot wg config"
  fi
  return $_ret
}

function wg_keys {
  _ret=1
  step="wg_keys"
  mark _wg
  cd $wg_top
  _msg "    $step create key files $wg_privkeyf $wg_publkeyf in $wg_top/"
  wg genkey | tee $wg_privkeyf | wg pubkey > $wg_publkeyf
  _ret=$?  
  chmod 600 "$wg_privkeyf"
  cd $_wg
  return $_ret  
}

function wg_scfg {
  _ret=1
  step="wg_scfg"
  _msg "    $step  create server config file $wg_fil"
  if [ -f "$wg_top/$wg_publkeyf" ] && [ -f "$wg_top/$wg_privkeyf" ]; then
    _publkey="`cat $wg_top/$wg_publkeyf`"
    _privkey="`cat $wg_top/$wg_privkeyf`"
    echo "# $hsautocreate wg config server"   > $wg_fil
    echo ""                                  >> $wg_fil
    echo "[Interface]"                       >> $wg_fil
    echo "PrivateKey = $_privkey"            >> $wg_fil
    echo "Address = $wg_ipsrv/24"            >> $wg_fil
    echo "MTU = 1420"                        >> $wg_fil
    echo "ListenPort = $wg_listenport"       >> $wg_fil
    echo ""                                  >> $wg_fil
    echo "[Peer]"                            >> $wg_fil
    echo "PublicKey = $_publkey"             >> $wg_fil
    if [ "$wg_presharedkey" != "" ]; then
      echo "PresharedKey = $wg_presharedkey" >> $wg_fil
    fi
    echo "AllowedIPs = $wg_ipclient/32"      >> $wg_fil  
    chmod 600 "$wg_fil"
    _ret=0
  else
    _msgerr "missing $wg_top/$wg_publkeyf, use hotspot wg config genkeys"
  fi
  return $_ret
}

function wg_ccfgOLD {
  _ret=1
  step="wg_ccfg"
  _msg "    $step create client config file $wg_fil"
  if [ "$wg_endpoint" != "" ]; then
    if [ "$wg_srvpubkey" != "" ]; then
      if [ -f "$wg_top/$wg_privkeyf" ]; then
        _privkey="`cat $wg_top/$wg_privkeyf`"
        echo "# $hsautocreate wg config client" > $wg_fil
        echo ""                                   >> $wg_fil
        echo "[Interface]"                        >> $wg_fil
        echo "PrivateKey = $_privkey"             >> $wg_fil
        echo "Address = $wg_ipclient/24"          >> $wg_fil
        if [ "$wg_dns" != "" ]; then
          echo "DNS = $wg_dns"                    >> $wg_fil
        fi
        echo ""                                   >> $wg_fil
        echo "[Peer]"                             >> $wg_fil
        echo "PublicKey = $wg_srvpubkey"          >> $wg_fil
        if [ "$wg_presharedkey" != "" ]; then
          echo "PresharedKey = $wg_presharedkey"  >> $wg_fil
        fi
        echo "Endpoint = $wg_endpoint"            >> $wg_fil       
        echo "AllowedIPs = 0.0.0.0/0, ::/0"       >> $wg_fil   
        _ret=0
        chmod 600 "$wg_fil"
      else
        _msgerr "missing $wg_top/$wg_privkeyf, use hotspot wg config genkeys"
      fi
    else
      _msgerr "no server public key defined, use hotspot modpar self wg_srvpubkey \"<wireguard_server_public_key>\""
    fi
  else
    _msgerr "no server Endpoint defined, use hotspot modpar self wg_endpoint \"<wireguard_server_endpoint>\""
  fi
  return $_ret
}

function wg_ccfg {
# 1:endpoint 2:ipaddr 3:dns 4:privkey 5:pubkey 6:preshrkey 
  _ret=1
  step="wg_ccfg"
  _msg "    $step create client config file $wg_fil"
  
  _endpoint="$1";  if [ "_endpoint" == "" ];  then _endpoint="$wg_endpoint"; fi
  _ipaddr="$2";    if [ "_ipaddr" == "" ];    then _ipaddr="$wg_ipclient"; fi
  _dns="$3";       if [ "_dns" == "" ];       then _dns="$wg_dns"; fi
  _privkey="$4";   if [ "_privkey" == "" ];   then _privkey="$wg_clientprivkey"; fi
  _srvpubkey="$5"; if [ "_srvpubkey" == "" ]; then _srvpubkey="$wg_srvpubkey"; fi
  _preshrkey="$6"; if [ "_preshrkey" == "" ]; then _preshrkey="$wg_presharedkey"; fi   
  
  if [ "$_endpoint" != "" ]; then
    if [ "$_srvpubkey" != "" ]; then
      if [ "$_privkey" != "" ]; then
        if [ "$_dns" != "" ]; then
          if [ "$_ipaddr" != "" ]; then
            echo "# $hsautocreate ($snam wg config client)" > $wg_fil
            echo ""                                   >> $wg_fil
            echo "[Interface]"                        >> $wg_fil
            echo "PrivateKey = $_privkey"             >> $wg_fil
            echo "Address = $_ipaddr/24"              >> $wg_fil
            if [ "$_dns" != "" ]; then
              echo "DNS = $_dns"                      >> $wg_fil
            fi
            echo ""                                   >> $wg_fil
            echo "[Peer]"                             >> $wg_fil
            echo "PublicKey = $_srvpubkey"            >> $wg_fil
            if [ "$_preshrkey" != "" ]; then
              echo "PresharedKey = $_preshrkey"       >> $wg_fil
            fi
            echo "Endpoint = $_endpoint"              >> $wg_fil       
            echo "AllowedIPs = 0.0.0.0/0, ::/0"       >> $wg_fil   
            chmod 600 "$wg_fil"
            _ret=$?
          else
            _msgerr "no client address, use hotspot modpar self wg_ipclient \"<ipaddr>\""
          fi
        else
          _msgerr "no dns, use hotspot modpar self wg_dns \"<dnsserver>\""
        fi
      else
        _msgerr "no client private key defined, use hotspot modpar self wg_clientprivkey \"<wireguard_client_private_key>\""
      fi
    else
      _msgerr "no server public key defined, use hotspot modpar self wg_srvpubkey \"<wireguard_server_public_key>\""
    fi
  else
    _msgerr "no server Endpoint defined, use hotspot modpar self wg_endpoint \"<wireguard_server_endpoint>\""
  fi
  return $_ret
}

function _gi {
# 1:question 2:defaultval 3:mode
  getinfo=""
  while [ "$getinfo" == "" ]; do
    read -p "[?] pls. enter $1: " -r getinfo
    case "$3" in
      0) # input can be empty
         break
         ;; 
      1) # use non empty defaultval, if getinfo is empty
         if [ "$2" != "" ] && [ "$getinfo" == "" ]; then
           getinfo="$2"
           break
         fi
         ;;
    esac
  done
}

function wg_ccfg_interactive {
  step="wg_ccfg_interactive"
  _msg "    $step create wireguard client config file $wg_fil"
  _msg "    $step default values taken from $snam modpar self <name> <value>"

  _gi "[Interface] PrivateKey ($wg_clientprivkey)" "$wg_clientprivkey" "1"; _privkey="$getinfo";
  _gi "[Interface] Address ($wg_ipclient)" "$wg_ipclient" "1"; _ipaddr="$getinfo";
  _gi "[Interface] DNS ($wg_dns)" "$wg_dns" "1"; _dns="$getinfo";
  _gi "[Peer] PublicKey ($wg_srvpubkey)" "$wg_srvpubkey" "1"; _srvpubkey="$getinfo";
  _gi "[Peer] PresharedKey ($wg_presharedkey)" "$wg_presharedkey" "0"; _preshrkey="$getinfo";
  _gi "[Peer] Endpoint ($wg_endpoint)" "$wg_endpoint" "1"; _endpoint="$getinfo";
  
#  echo "PrivateKey:   $_privkey"
#  echo "Address:      $_ipaddr"
#  echo "DNS:          $_dns"
#  echo "PublicKey:    $_srvpubkey"
#  echo "Endpoint:     $_endpoint"
#  echo "PresharedKey: $_preshrkey"
 
  wg_ccfg "$_endpoint" "$_ipaddr" "$_dns" "$_privkey" "$_srvpubkey" "$_preshrkey"
  _ret=$?
  
  if [ $_ret -eq 0 ]; then cat $wg_fil; fi
  return $_ret
}

function wg_menu {
  _ret=1
  case "$1" in
        start)
            wg_up "$2" "$3"
            _ret=$?
            ;;
        stop)
            wg_dwn "$2" "$3"
            _ret=$?
            ;;
        config)
            case "$2" in
              client)
                wg_ccfg_interactive
                _ret=$?
                ;;
#             server)
#               wg_scfg "$3"
#               _ret=$?
#               ;;
#             genkeys)
#               wg_keys "$3"
#               _ret=$?
#               _msgerr "client only"
#               ;;
              *) echo "Usage: $snam wg config [client]"
            esac
            ;;
        *) echo "Usage: $snam wg [start [cfg] | stop [cfg] | config client]"
  esac
  return $_ret
}

function stop_ap_dev {
  _ret=1
  if [ "$1" != "" ]; then
    ip -force link set dev "$1" down
    ip addr flush dev "$1"
    _ret=$?
  fi
  return $_ret
}

function inst_ap_dev {
  _ret=1
  wdev="$1"
  if [ "$wdev" != "$ap_dev" ] && [ "$wdev" != "" ]; then
    _msg "    install & check dev $ap_dev"
    apnet255=`ip addr show dev "$ap_dev" 2>/dev/null | awk '/inet / { print $4 }'`
    if [ "$ap_subn" != "$apnet255" ]; then
      _msg "    assign  dev $ap_dev $ap_ipanet on $wdev"
      iw dev $wdev interface add $ap_dev type __ap
      stop_ap_dev "$ap_dev"
#     ip link set $ap_dev address $ap_devmac
      ip a add "$ap_ipanet" brd + dev "$ap_dev"
      ip link set dev "$ap_dev" up
    fi
    apipn=`ip addr show dev "$ap_dev" 2>/dev/null | awk '/inet / { print $2 }'`
    if [ "$apipn" == "$ap_ipanet" ]; then
      _msg "    install dev $ap_dev on $wdev done"
      _ret=0
    else
      _msgerr "  install dev $ap_dev"
    fi
  fi
  return $_ret
}

function wlan {
  _ret=1
  if [ "$wl1_avail" != "yes" ]; then wl_dev="$wl0_dev"; else wl_dev="$wl1_dev"; fi
  if [ "$2" != "" ]; then wl_dev="$2"; fi
  case "$1" in
        start)
            _msg "    start   wlan    $wl_dev"
            systemctl restart dhcpcd
            _ret=$?
#           wpa_cli -i $wl_dev reconfigure
		    _ret=$?
            ;;
        stop)
            _msg "    stop    wlan    $wl_dev"
            wpa_cli -p $wpactrl -i $wl_dev terminate >/dev/null 2>&1
            _ret=$?
            ;;
        clean)
            _msg "    clean   wlan    $wl_dev"
            wpa_cli terminate >/dev/null 2>&1
            ip addr flush $wl_dev
            ip link set dev $wl_dev down
            rm -r /var/run/wpa_supplicant >/dev/null 2>&1
            _ret=$?
            ;;
        check)
            if [ "$wl_dev" != "" ]; then
              status=`wpa_cli -i $wl_dev status | grep wpa_state`
              if [ "$status" != "wpa_state=COMPLETED" ]; then
                _msgerr "  wlan    $wl_dev $status"
              else
                _msgsuc "  wlan    $wl_dev"
                _ret=0
              fi
            fi
            ;;
        *)
            echo "Usage: $snam wlan start|stop|check|clean [$wl0_dev|$wl1_dev]"
  esac
  return $_ret
}

function do_fwd {
  _ret=1
  case "$1" in
        wipe)
            fwd_wipe "$2" "$3" "$2"
            _ret=$?
            ;;
        inst)
            fwd_do "$2" "$3" "$4"
            _ret=$?
            ;;
        list)
            fwd_list "$2" "$3" "$4"
            _ret=$?
            ;;
        log)
            fwd_log "$2" "$3" "$4"
            _ret=$?
            ;;
        *)
            echo "Usage: $snam fwd wipe | inst | list | log"
  esac
  return $_ret
}

function do_ovpn {
  _ret=1
  Check_installed_PKG
  if [ -d "$vpngdir" ]; then
    case "$1" in
        start)
            if [ -f "$ovpnfil" ]; then
              _msg "    start   openvpn on $ovpn_dev"
              ovpn_check_running
              IP4_fwdSet "1"
              _msg "    ovpn    on $ovpn_dev as service openvpn@$ovpncfg"
              systemctl start openvpn@$ovpncfg           
#             wait max. 60sec for tun device gets an IPadr
              i="0"
              ovpn_ip=""
              while [ $i -le 60 ] && [ "$ovpn_ip" == "" ]; do
                sleep 1
                ovpn_ip=`ip addr show dev "$ovpn_dev" 2>/dev/null | awk '/inet / { print $2 }'`
                _msg "    ovpn    wait for $ovpn_dev to come up"
                i=$[$i+1]
              done
              if [ "$ovpn_ip" != "" ]; then
                _msg "    OK ovpn $ovpn_dev $ovpn_ip"
                fwd_do         "add" "ovpn"
                fwd_ovpn_part2 "add" "$apperm"
                _ret=$?
                if [ $_ret -eq 0 ]; then showip "ovpn"; fi
#               fwd_stat "ovpn"
              else
                _msgerr "  ovpn    no IPassignment on $ovpn_dev"
              fi
            else
              _msgerr "  ovpn    no config file found $ovpnfil"
            fi   
            ;;
        stop)
            _msg "    stop    openvpn"
            if [ -f "$ovpnfil" ]; then
              systemctl stop openvpn@$ovpncfg
            fi
            ovpn_check_running
            fwd_do         "remove" "ovpn"
            _ret=$? 
            fwd_ovpn_part2 "remove" "$apperm"
            _ret=$? 
            ;;
        refresh)
            _msg "    refresh openvpn config files"
            ovpn_cfg_dwn
            _ret=$? 
            ;;
        *)
            echo "Usage: $snam ovpn start|stop"
    esac
  else
    _msgerr "ovpn not installed"
  fi
  return $_ret
}

function do_tor {
  _ret=1
  Check_installed_PKG
  if [ -d "$tordir" ]; then
    case "$1" in
        start)
            _msg "    start   tor"
            fwd_do "add" "tor"
            _ret=$?
#           service dnsmasq stop
            service tor     restart
#           if [ $_ret -eq 0 ]; then showip "tor"; fi
            _msg "    check   tor functionality: https://check.torproject.org/"
#           fwd_log all
#           fwd_stat "tor"
            ;;
        stop)
            _msg "    stop    tor"
            service tor     stop
            fwd_do "remove" "tor"
            _ret=$?
#           service dnsmasq restart
#           fwd_log off
            ;;
        *)
            echo "Usage: $snam tor start|stop"
    esac
  else
    _msgerr "tor not installed"
  fi
  return $_ret
}

function do_syslog {
  if [ "$1" != "" ]; then lins="-A $1"; else lins=""; fi
  tail -500 /var/log/syslog | grep --color -a $lins "${snam}"
}

function Find_Chan {
# find best (least used) channel
# Find_Chan "wlan1" "11" "104" "5"
  _ret=1
  chanw=""
  chflg=""
  chvtc=""
  chhtc=""
  if [ "$ch_autofind" -gt "0" ]; then
    if [ "$1" != "" ]; then
      fil="/tmp/$1_$4_scan.txt"
      iwlist $1 chan 2>/dev/null | grep -i " : $4" | sed 's/  //g' | sed 's/Channel 0//g' | sed 's/Channel //g' | awk -F " " '{ print $1 }' > $fil
      iwlist $1 scan 2>/dev/null | grep -i "Frequency:$4" | sort | uniq -c | sort -n | sed 's/  //g' | sed 's/)//g' | awk -F " " '{ print $5 }' >> $fil
      linr=0
      ch_prio_arr=($ch_prio)
      while read line; do
        linr=$(($linr+1))
        ch_use=`echo "$line" | awk '{print $1}'`
        ch_num=`echo "$line" | awk '{print $2}'`
#       echo "ch: $ch_num use: $ch_use"
        if [ "$linr" -le "1" ]; then chanw="$ch_num"; fi
#       echo "linr: $linr ch: $chanw"
        idx=0
        while [ "${ch_prio_arr[idx]}" != "" ]; do
          if [ "$ch_num" == "${ch_prio_arr[idx]}" ] && [ "$ch_use" -le "1" ]; then
            chanw="$ch_num"
            _ret=0
#           echo "found idx: $idx ch: $chanw use: $ch_use"
          fi
          idx=$(($idx+1))
        done
      done <<< $(cat $fil | sort | uniq -c | sort -n)
    fi
  else
    chanw="$3"
  fi
  if [ "$chanw" == "" ]; then chanw="$2"; fi
  if [ "$chanw" == "" ]; then chanw="$ch_dflt"; fi
  return $_ret
}

function Mdfy_Chan {
  _ret=0
  _msg "    modify  channel strategy: $1 $2 $3"
  ch="$2"
  if [ "$ch" == "" ]; then
    ch="$ch_dflt"
    _msg "    using   default chan $ch"
  fi
  if [ "$ch" -le "14" ]; then hm="g"; else hm="a"; fi
  if [ "$ch" -ge "32" ]; then att="$ch (can cause problem)"; else att="$ch"; fi
  _msg "    select  hw_mode $hm  chan $att"
  Mod_Para "hostapd" "channel" "$ch"
  Mod_Para "hostapd" "hw_mode" "$hm"
  return $_ret
}

function svc_showstat {
  if [ "$1" != "" ]; then
    msg="`service $1 status | grep -i \"Active:\" | awk -F " " '{ print $2" "$3 }'`"
    _msg "$1     $msg"
  fi
}

function Hotspot_Start {
  _ret=1
  Check_installed_PKG
  Hotspot_Defines
  ext_ip=`dig txt o-o.myaddr.test.l.google.com @ns1.google.com +short -4 | sed 's/"//g'`
  _msg "starting    $snam $hotspotver usr:$usr"
  _msg "    extIP   router  $ext_ip"
  _msg "    ETHER   $eth_dev    $eth_ip"
  _msg "    WLANint $wl0_dev   $wl0_ip"
  _msg "    WLANext $wl1_dev   $wl1_ip"
  chanh=`cat "$hostapdf" | awk '/channel=/ { print $1 }' | sed 's/channel=//g'`
  if [ "$chanh" != "0" ]; then
    if [ "$ap_share" != "yes" ] && { [ "$wl1_avail" == "yes" ] || [ "$eth_ip" != "" ]; }; then
      Find_Chan "$wl0_dev" "$ch_dflt" "$chanh" "$freq_filter"
      _msg "    FndChan suggest channel $chanw"
      msg="select channel for ap mode"
    else
      chanw=`iwlist $wl0_dev channel | awk '/urrent / { print $5 }' | sed 's/)//g'`
      msg="select same channel for ap & station mode on $wl0_dev"
      _msg "    UseChan channel $chanw"
    fi
    if [ "$chanw" != "" ]; then
      Mdfy_Chan "$msg" "$chanw" "$chanh"
    fi
  else
    _msg "    UseAuto channel selection"
  fi
  if [ "$1" == "nowlan" ]; then wlan stop $wl0_dev; fi
  _msg "    stop    hostapd"
  systemctl stop hostapd
  _msg "    stop    dnsmasq"
  systemctl stop dnsmasq
  IP4_fwdSet "1"
  inst_ap_dev $wl0_dev
  sleep 1

  fwd_do   "add" "ap"
  _msg "    start   hostapd restart"
  systemctl restart  hostapd
  _msg "    start   dnsmasq"
  systemctl restart dnsmasq
  
  if [ "$nodogsplashstart" == "yes" ]; then
    _msg "start     captive portal (nodogsplash)"
    nodogsplash
  fi
  
  _vpnmode=""
  if [ "$wgstart" == "yes" ]   && [ -d "$wg_top" ];  then _vpnmode="wg";   fi
  if [ "$ovpnstart" == "yes" ] && [ -d "$vpngdir" ]; then _vpnmode="ovpn"; fi

  case "$_vpnmode" in
    ovpn)
      if [ "$ovpnrefreshbeforestart" == "yes" ]; then ovpn_refresh; fi
#     _msgdat "ovpn start"
      do_ovpn start    
      ret=$?
      ;;
    wg)
      wg_up
      ret=$?
      ;;
    *) 
      fwd_def remove interface "$ovpn_dev" "$2" "$ovpnzone" "Hotspot_Start"  
      fwd_def remove interface "$wg_dev"   "$2" "$wgzone"   "Hotspot_Start"
      fwd_if  add "$apperm" 
      _ret=$?
      ;;
  esac
  
  if [ "$torstart" == "yes" ]; then 
    do_tor start "$apperm"
    _ret=$?
  fi

  svc_showstat dnsmasq
  svc_showstat hostapd
# _msg "started   $snam"
  return $_ret
}

function Hotspot_Try {
  _ret=1
  Check_installed_PKG
  echo "trying      $snam $hotspotver usr:$usr"
# wait max. 15sec for wlan0 gets an IPadr from DHCP if eth0 is not connected
  i="0"
  while [ $i -le 15 ] && [ "$wl0_ip" == "" ] && [ "$eth_ip" == "" ]; do
    sleep 1
    Hotspot_Defines
    _msg "    dhcp    wait for IPadr on $wl0_dev $wl0_ip"
#   Show_Defines
    i=$[$i+1]
  done
  if [ "$wl0_ip" == "" ]; then
    _msgerr "    dhcp    no IPassignment on $wl0_dev"
  fi
  if [ "$hs_try" == "yes" ] && [ "$ap_share" != "yes" ]; then
    _msg "    try     $snam"
    Hotspot_Start nowlan
    _ret=$?
  else
    if [ "$ap_share" == "yes" ]; then
      if [ "$wl0_subn" != "" ] && [ "$wl0_subn" != "$ap_subn" ]; then
        _msg "    ap&sta  on $wl0_dev start $snam in parallel to station mode"
        _msg "    (not supported, use eth0 or additional usb wlan adaptor wlan1)"
#       _msg "    starting $snam, maybe this will fail"
        Hotspot_Start wlan
        _ret=$?
      else
        _msgerr "    subnet conflict $eth_dev $eth_subn $wl0_dev $wl0_subn $ap_dev $ap_subn"
      fi
    else
      _msg "    param   ap_share not set to yes"
    fi
  fi
  qrcode_on_oled "try" "$acc_info"
  return $_ret
}

function Hotspot_Stop {
  _ret=1
  Check_installed_PKG
  _msg "stopping  all ovpn instances"
  ovpn_check_running
  _msg "stopping  $snam"
  _msg "    stop    hostapd"
  systemctl stop hostapd
  sleep 2
  _msg "    stop    dnsmasq"
  systemctl stop dnsmasq
  IP4_fwdSet "0"
  fwd_do "remove" "ap"
  _ret=$?
  sleep 2
  if [ "$1" != "nowlan" ]; then
    systemctl daemon-reload
    wlan start $wl0_dev
    sleep 10
  fi
  _msg "    link    down dev $ap_dev"
  stop_ap_dev "$ap_dev"
  _ret=$?
  iw dev $ap_dev del
  _msg "stopped   $snam"
  return $_ret
}

function Setup_rclocal {
  fil="/etc/rc.local"
  fil2="/etc/issue"
  fil_bck "$fil"  "$bckext"
  fil_bck "$fil2" "$bckext"
  _msg "create $fil"
  cat <<EOF > "$fil"
#!/bin/sh -e
# $hsautocreate

# Print the IP address
_IP=\$(hostname -I) || true
if [ "\$_IP" ]; then
  printf "IP %s\nRaspbian GNU/Linux\n" "\$_IP" > /etc/issue
else
  printf "Raspbian GNU/Linux\n" > /etc/issue
fi

exit 0
EOF
  chmod 750 "$fil"
}

function Setup_ServiceFile {
  fil="/lib/systemd/system/$snam.service"
  fil_bck "$fil"  "$bckext"
  _msg "create $fil"
  cat <<EOF > "$fil"
[Unit]
Description=$snam
After=network.target syslog.target
Wants=network.target

[Service]
Type=oneshot
WorkingDirectory=/usr/local/sbin
ExecStart=/usr/local/sbin/$snam try
StandardOutput=journal
StandardError=journal
SyslogIdentifier=$snam
#StandardOutput=file:/tmp/$snam.log
#StandardError=file:/tmp/$snam.log

[Install]
WantedBy=multi-user.target
EOF
  chmod 644 "$fil"
}

function Setup_sysctlconf {
  fil="/etc/sysctl.conf"
  fil_bck "$fil" "$bckext"
# net.ipv4.ip_forward=1
  grep -q -F "net.ipv4.ip_forward=" $fil || echo "net.ipv4.ip_forward=" >> $fil
  sed -r -i 's/net\.ipv4\.ip_forward[ ]*=.*/net\.ipv4\.ip_forward=1/g' $fil
  sed -r -i 's/#net\.ipv4\.ip_forward=1/net\.ipv4\.ip_forward=1/g' $fil
}

function Setup_dhcpcdconf {
  fil="/etc/dhcpcd.conf"
  fil_bck "$fil" "$bckext"
  _msg "create $fil"
  cat <<EOF > "$fil"
hostname
clientid
persistent
option rapid_commit
option domain_name_servers, domain_name, domain_search, host_name
option classless_static_routes
option ntp_servers
option interface_mtu
require dhcp_server_identifier
slaac private

timeout 25

denyinterfaces ap0
interface ap0
  nohook wpa_supplicant
  #static ip_address=10.3.141.1/24
EOF
  chmod 664 "$fil"
  chown root:netdev "$fil"
}

function Setup_dnsmasqconf {
  _dir="/etc/${snam}" 
  if [ ! -d "$_dir" ]; then 
    mkdir -p $_dir >/dev/null 2>&1
    chmod 755 "$_dir"
  fi
  
  _dir="/etc/dnsmasq.d"
  if [ ! -d "$_dir" ]; then 
    mkdir -p $_dir >/dev/null 2>&1
    chmod 755 "$_dir"
  fi

  fil="/etc/dnsmasq.conf"
  _okdir=`cat "$fil" | awk -F "conf-dir=" '{print $2}'`
  if [ "$_dir" != "$_okdir" ]; then
    fil_bck "$fil" "$bckext"
    echo "conf-dir=$_dir" > $fil
    chmod 644 "$fil"
  fi
  
  rm "$_dir/*_${snam}*" 2>/dev/null
  
  fil="$_dir/01_${snam}.conf"
# fil_bck "$fil" "$bckext"
  _msg "create $fil"
  cat <<EOF > "$fil"
# $hsautocreate

# interface=$ap_dev                   # Use $snam interface
no-dhcp-interface=eth0,wlan0    # Don't use these interfaces
listen-address=$ap_ip       # Explicitly specify the $snam address to listen on
listen-address=127.0.0.1        # Explicitly specify localhost ip4
bind-interfaces                 # Bind to the interface to make sure we aren't sending things elsewhere
domain-needed                   # Don't forward short names
# bogus-priv                      # Never forward addresses in the non-routed address spaces

local-ttl=2
local-service
localise-queries

# ========== [ nameserver ] ==========

no-hosts # Do not read /etc/hosts
# Read additional hosts-file (not only /etc/hosts) to add entries into DNS
# addn-hosts=/etc/${snam}/dnsmasq_static_hosts.list
expand-hosts
domain=$ns_dom
local=/$ns_dom/$ap_ip

# Host & PTR & Reverse
host-record=$hostn.$ns_dom,$ap_ip
server=/$ap_revnet.in-addr.arpa/$ap_ip
ptr-record=$ap_revip.in-addr.arpa,$hostn.$ns_dom  

# ========== [ dhcp ] ==========

dhcp-mac=set:client_is_a_pi,B8:27:EB:*:*:*
dhcp-mac=set:client_is_a_pi,DC:A6:32:*:*:*
dhcp-reply-delay=tag:client_is_a_pi,2

dhcp-range=$ap_net.50,$ap_net.199,255.255.255.0,12h
dhcp-option=option:router,$ap_ip
# dhcp-option=option:ntp-server,$ap_ip

dhcp-option=vendor:MSFT,2,1i # Tell MS Windows to release a lease on shutdown
dhcp-option=44,$ap_ip    # set netbios-over-TCP/IP aka WINS
dhcp-option=45,$ap_ip    # netbios datagram distribution server
dhcp-option=46,8             # netbios node type
dhcp-option=252,"\n"         # REQUIRED to get win7 to behave
dhcp-option=160,http://10.3.141.1/index.html # RFC 7710

# DHCPv4 Should be set when dnsmasq is definitely the only DHCP server on a network
# dhcp-authoritative
# DHCPv4 Server will attempt to ensure that an address is not in use before allocating it to a host
# no-ping

# ========== [ etc ] ==========

log-facility=/var/log/syslog
# log-queries
# log-dhcp
log-async
EOF
  chmod 644 "$fil"

  fil="$_dir/05_${snam}_captiveportal.conf"
  if [ "$dnsmasqcpf" == "yes" ]; then
# fil_bck "$fil" "$bckext"
    _msg "create $fil"
    cat <<EOF > "$fil"
# $hsautocreate

# Captive Portal
# DNS Internet Connectivity Test Domains
# redirect all requests
#address=/#/$ap_ip
# specific platform redirects
# Android
address=/clients1.google.com/$ap_ip
address=/clients3.google.com/$ap_ip
address=/connectivitycheck.android.com/$ap_ip
address=/connectivitycheck.gstatic.com/$ap_ip
# IOS
address=/captive.apple.com/$ap_ip
# WIN
address=/www.msftconnecttest.com/$ap_ip
address=/dns.msftncsi.com/$ap_ip
address=/www.msftncsi.com/$ap_ip
# Mozilla Firefox, Mozilla Thunderbird, SeaMonkey
address=/detectportal.firefox.com/$ap_ip

# DHCP
#dhcp-option=160,$ap_cauri # RFC 7710
EOF
    chmod 644 "$fil"
  else
    rm "$fil" >/dev/null 2>&1
  fi
}

function Setup_hostapddflt {
  fil="/etc/default/hostapd"
  fil_bck "$fil" "$bckext"
  _msg "create $fil"
  cat <<EOF > "$fil"
#RUN_DAEMON=yes
DAEMON_CONF="/etc/hostapd/hostapd.conf"
EOF
  chmod 600 "$fil"
}

function Setup_hostapdconf {
  fil="/etc/hostapd/hostapd.conf"
  fil_bck "$fil" "$bckext"
  _msg "create $fil"
  cat <<EOF > "$fil"
ctrl_interface=/var/run/hostapd
ctrl_interface_group=0
interface=$ap_dev
driver=nl80211
ignore_broadcast_ssid=0
ap_isolate=0

channel=6
hw_mode=g

country_code=$spot_cntry2
ieee80211d=1

ssid=$spot_ssid
wpa_passphrase=$spot_psk

wpa=2
wpa_key_mgmt=WPA-PSK
rsn_pairwise=CCMP

ieee80211n=1

ieee80211ac=1
wmm_enabled=1
macaddr_acl=0
auth_algs=1

logger_syslog=-1
logger_syslog_level=4
logger_stdout=-1
logger_stdout_level=4
EOF
  _msg "$snam:   setting default (pls. adjust ssid, wpa_passphrase, country_code and REGDOMAIN)"
  Mdfy_Chan "select default channel"
  Mod_Para  "hostapd" "ssid" "$spot_ssid"
  Mod_Para  "hostapd" "wpa_passphrase" "$spot_psk"
  Mod_Para  "hostapd" "country_code" "$spot_cntry2"
  Mod_Para  "crda"    "REGDOMAIN"    "$spot_cntry2"
# Mod_Para  "self" "autostart" "yes"
  chmod 640 "$fil"
}

function Setup_torcfg {
  if [ -d "$tordir" ]; then
    fil="$torcfg"
    fil_bck "$fil" "$bckext"
    _msg "create $fil"
    cat <<EOF > "$fil"
#Log debug file /var/log/tor/debug.log
#Log notice syslog
Log notice stderr
#VirtualAddrNetwork $tor_subn
VirtualAddrNetworkIPv4 $tor_subn
#AutomapHostsSuffixes .onion,.exit
AutomapHostsOnResolve 1
TransPort ${ap_ip}:${tor_trans_port}
DNSPort ${ap_ip}:${tor_dns_port}
EOF
    chmod 644 "$fil"
    touch /var/log/tor-notices.log >/dev/null 2>&1
    chown debian-tor /var/log/tor-notices.log >/dev/null 2>&1
    chmod 644 /var/log/tor-notices.log >/dev/null 2>&1
  fi
}

function Hotspot_Setup {
  _msg "Setup  $snam $1 $2 ..."
  if [ "$1" != "noswpkg" ]; then
    _msg "install sw packages"
    apt-get -qy update
    apt-get -qy install iw firewalld hostapd dnsmasq fbi wget qrencode $aptaddinstlist
    ovpn_refresh
  fi
# disable/stop services. starting by script if needed
  systemctl disable dnsmasq.service >/dev/null 2>&1
  systemctl stop    dnsmasq.service >/dev/null 2>&1
  systemctl disable openvpn.service >/dev/null 2>&1
  systemctl stop    openvpn.service >/dev/null 2>&1
  systemctl unmask  hostapd.service >/dev/null 2>&1
  systemctl disable hostapd.service >/dev/null 2>&1
  systemctl stop    hostapd.service >/dev/null 2>&1
  update-rc.d tor   disable >/dev/null 2>&1
  service tor stop  >/dev/null 2>&1

  bckext=`date +"%Y%m%d%H%M%S"`

  Setup_rclocal     $1 $2
# Setup_sysctlconf  $1 $2
  Setup_dhcpcdconf  $1 $2
  Setup_dnsmasqconf $1 $2
  Setup_hostapddflt $1 $2
  Setup_hostapdconf $1 $2
  Setup_torcfg      $1 $2
  Setup_ServiceFile $1 $2
  Hotspot_Enable    $1 $2
}

ret=0
Hotspot_Defines
case "$opt1" in
        try)
            Hotspot_Try   "$opt2"
            ret=$?
            ;;
      start)
            Hotspot_Start "$opt2"
            ret=$?
            ;;
       stop)
            Hotspot_Stop  "$opt2"
            ret=$?
            ;;
     enable)
            Hotspot_Enable "$opt2"
            ;;
    disable)
            Hotspot_Disable "$opt2"
            ;;
  startmode)
            case "$opt2" in
              try)
                if [ "$autostart" == "yes" ]; then
		   echo "ERR: since V0.960 not needed, started by systemd"
#                 Hotspot_Try "$opt3"
                fi
                ret=1
              ;;
              start)
                if [ "$autostart" == "yes" ]; then
		  echo "ERR: since V0.960 not needed, started by systemd"
#                 Hotspot_Start "$opt3"
                fi
                ret=1
              ;;
              *)
                echo "$autostart"
              ;;
            esac
            ;;
    restart)
            Hotspot_Stop   nowlan
            echo "  20sec  settle time"
            sleep 20
            Hotspot_Start "$opt2"
            ret=$?
            ;;
      retry)
            Hotspot_Stop   nowlan
            echo "  20sec  settle time"
            sleep 20
            Hotspot_Try   "$opt2"
            ret=$?
            ;;
       wlan)
            wlan          "$opt2" "$opt3"
            ;;
     modpar)
            Mod_Para      "$opt2" "$opt3" "$opt4"
            ;;
    setchan)
            Mdfy_Chan     "given_by_cli" "$opt2" "given_by_cli"
            ;;
      setup)
            Hotspot_Setup "$opt2" "$opt3"
            ;;
     syslog)
            do_syslog     "$opt2"
            ;;
        tor)
            do_tor        "$opt2"
            ;;
       ovpn)
            do_ovpn       "$opt2"
            ;;
       wg)     
            wg_menu       "$opt2" "$opt3" "$opt4"
            ;;
       fwd)
            do_fwd        "$opt2" "$opt3" "$opt4"
            ;;
    qrcode)
#           echo "qrcode_on_oled $acc_info"
            qrcode_on_oled "interactive" "$acc_info"
            ;;
    version)
            echo "$hotspotver"
            ;;
     status)
            Hotspot_Status
            ;;
     dbg)
            Show_Defines  "$opt2" "$opt3" "$opt4"
            ;;
          *)
  echo "Usage: $snam try | start [nowlan] | stop [nowlan] | enable | disable | retry | restart [nowlan] | status | setup | setchan [channel] | syslog [lines] | fwd [wipe|install|list] | tor [start|stop] | ovpn [start|stop|refresh] | wg [start|stop|config] | modpar <crda|dnsmasq|hostapd|self> <name> [value] | version | dbg | qrcode | wlan start|stop|check|clean [$wl0_dev|$wl1_dev]"
esac
exit $ret
